
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="ZhechongHuang">
      
      
        <link rel="canonical" href="https://cudraniatrec.github.io/Blog/ProgramSynthesis-unit2/">
      
      
        <link rel="prev" href="../ProgramSynthesis-unit1/">
      
      
        <link rel="next" href="../conda%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.14">
    
    
      
        <title>ProgramSynthesis-unit2 - ZhechongHuang's Homepage</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.fad675c6.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="amber">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lecture-10-introduction-to-functional-synthesis" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="ZhechongHuang&#39;s Homepage" class="md-header__button md-logo" aria-label="ZhechongHuang's Homepage" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ZhechongHuang's Homepage
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ProgramSynthesis-unit2
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="amber"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="pink" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/CudraniaTrec/cudraniatrec.github.io/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="ZhechongHuang&#39;s Homepage" class="md-nav__button md-logo" aria-label="ZhechongHuang's Homepage" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    ZhechongHuang's Homepage
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CudraniaTrec/cudraniatrec.github.io/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10A10 10 0 0 0 12 2M7 9.5C7 8.7 7.7 8 8.5 8s1.5.7 1.5 1.5S9.3 11 8.5 11 7 10.3 7 9.5m5 7.73c-1.75 0-3.29-.73-4.19-1.81L9.23 14c.45.72 1.52 1.23 2.77 1.23s2.32-.51 2.77-1.23l1.42 1.42c-.9 1.08-2.44 1.81-4.19 1.81M15.5 11c-.8 0-1.5-.7-1.5-1.5S14.7 8 15.5 8s1.5.7 1.5 1.5-.7 1.5-1.5 1.5Z"/></svg>
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../soot-tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    soot
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ProgramSynthesis-unit1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Program Synthesis 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Program Synthesis 2
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Program Synthesis 2
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lecture-10-introduction-to-functional-synthesis" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 10: Introduction to functional synthesis.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-11-a-brief-introduction-to-constraint-based-verification" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 11: A brief introduction to constraint-based verification.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-12-from-verification-conditions-to-synthesis-conditions" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 12: From Verification Conditions to Synthesis Conditions.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-13-functional-synthesis-with-sketch" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 13: Functional Synthesis with Sketch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-14-introduction-to-smt" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 14: Introduction to SMT.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-15-expressive-types" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 15: Expressive Types.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-16-synthesis-with-refinement-types" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 16: Synthesis with Refinement Types.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-17-deductive-synthesis" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 17: Deductive Synthesis
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../conda%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    conda install
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Linux%28wsl2%29%2Bcuda%2Bcudnn%2Bpytorch%E5%AE%89%E8%A3%85/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cuda+cudnn+pytorch install
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lecture-10-introduction-to-functional-synthesis" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 10: Introduction to functional synthesis.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-11-a-brief-introduction-to-constraint-based-verification" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 11: A brief introduction to constraint-based verification.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-12-from-verification-conditions-to-synthesis-conditions" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 12: From Verification Conditions to Synthesis Conditions.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-13-functional-synthesis-with-sketch" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 13: Functional Synthesis with Sketch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-14-introduction-to-smt" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 14: Introduction to SMT.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-15-expressive-types" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 15: Expressive Types.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-16-synthesis-with-refinement-types" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 16: Synthesis with Refinement Types.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lecture-17-deductive-synthesis" class="md-nav__link">
    <span class="md-ellipsis">
      Lecture 17: Deductive Synthesis
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>Program Synthesis 2</h1>

<h4 id="lecture-10-introduction-to-functional-synthesis">Lecture 10: Introduction to functional synthesis.<a class="headerlink" href="#lecture-10-introduction-to-functional-synthesis" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>从现在开始，我们需要了解spec的形式更加丰富的时候的程序合成。这里可的合成方法可以被称为functional synthesis，除此之外还有其他的合成方法例如reactive synthesis(在运行过程之中随着输入输出动态调整)等。</p>
</li>
<li>
<p>通常来说，我们需要面对3个主要的问题，建立spec的形式，正确性验证以及确定搜索策略。有些搜索策略会将正确性验证深度嵌入，确保最后生成的程序一定是正确的，有些策略则选择将搜索与验证完全解耦合，使得其各自独立解决。也有一些方法利用正确性约束指导搜索过程，并使得所生成的程序易于验证。</p>
</li>
<li>
<p>传统的spec形式是分为precondition与postcondition。我们对于问题的描述常常会存在不准确或者不直观的问题，此时可以借鉴多态的思想，例如传递给synthesizer一个可能不完备的condition，然后又继续传递一个例子，使其能够明白真正的意思。</p>
</li>
<li>
<p>high level地说，我们有4种方式确保程序正确性</p>
<ol>
<li>constraint-based techniques based on symbolic execution</li>
<li>abstract interpretation,</li>
<li>type-based analysis</li>
<li>deductive verification.</li>
</ol>
</li>
<li>
<p>基于constraint的技术可以简单地看作对于任意的输入IN，要求程序满足<span class="arithmatex">\(Q(IN)\)</span>。这一类的方法包含generating verification conditions，bounded model-checking等。不难发现，引入更多的参量来对程序进行限制有利于合成出我们想要的程序，但是过多的参量比较难以处理。一种想法是参量替代，但是比较难以进行。</p>
</li>
</ol>
<p>当下可以采取的方法一般是参量消除或者Counterexample Guided Inductive Synthesis(CEGIS)。参量消除通常可能会导致在消除参量的过程之中导致spec的size指数级膨胀，但是有时它也会带来一些简化。而且这种思路也可以作为尝试其他策略之前的预处理。</p>
<ol>
<li>
<p>CEGIS的逻辑很简单，就是不断试图找到当前程序的一个反例，然后利用这个反例大大缩减程序空间，直到最后无法找到反例。但是这种思想却非常通用，它将inductive synthesis与 expressive specifications以及valiadtion结合在了一起。<img alt="10-1" src="10-1.png" /></p>
</li>
<li>
<p>但是CEGIS只适用于一个反例可以否决掉大量可能程序的例子之中，如果反之，一个反例只能否决掉一个程序，而我们需要考虑的程序又有很多，那么CEGIS会非常低效。究其原因，这是因为CEGIS处理verification的思路仍然是需要从一个极大的空间之中寻找，如果我们可以将synthesis过程设计得易于验证，那么效率或许将有极大的提升。</p>
</li>
</ol>
<h4 id="lecture-11-a-brief-introduction-to-constraint-based-verification">Lecture 11: A brief introduction to constraint-based verification.<a class="headerlink" href="#lecture-11-a-brief-introduction-to-constraint-based-verification" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>我们需要更加形式化地表达对于目标程序的限制关系，从而对于一个程序的性质进行验证或证明。我们需要引入公理语义来表述程序的逻辑信息。定义<span class="arithmatex">\(\{A\}cmd\{B\}\)</span>,表示从满足A的状态出发，经过cmd指令，如果可以终止，程序一定可以达到满足B的状态，这个叫做partial correct，（因为不保证终止）。<span class="arithmatex">\([A]cmd[B]\)</span>在之前的基础之上，保证程序一定可以终止，这也可以叫做full correct。</p>
</li>
<li>
<p>可以定义以下的推导规则：<img alt="11-1" src="11-1.png" /></p>
<p>其中横线上方的命题如果都得到满足，就可以退出横线下方的命题。当我们想证明的<span class="arithmatex">\(\{A\}cmd\{B\}\)</span>的cmd是由多个基础指令拼接而来的，就可以反复应用上述规则对于待证明的命题进行拆分。但是对于循环，想要找到满足条件的A通常是很困难，并且只能由人工完成的一件事。</p>
</li>
<li>
<p>直接进行推导通常会涉及许多的人力投入，因此可以引入另一种更加自动化的方法。我们定义weakest precondition(wpc)为使得某个命题成立的最弱的条件，即<span class="arithmatex">\(\forall A, (\{A\}cmd\{B\})\Rightarrow (A\Rightarrow wpc(cmd,B))\)</span>。这样如果能够快速找到求wpc的方法，我们就可以迅速验证从当前状态出发可否得到目标性质。简单的求wpc的方法如下<img alt="11-2" src="11-2.png" /></p>
</li>
<li>
<p>但是这对于循环来说仍然难以解决，所以我们需要引进verification condition(vc),这是一个比wpc更强的条件，也就意味着我们依然可以通过<span class="arithmatex">\(A\Rightarrow vc(cmd,B)\)</span>来表明命题成立。具体到对于循环，可以如下来求出vc<img alt="11-3" src="11-3.png" />
    但是注意到这里的I是一个关于循环的常量，而且通常需要我们给出，因为虽然I任意取都可以，但是如果取得不好就会导致vc所要求的precondition过于强，甚至是无法满足式，对于我们的证明就无助了。因此这需求人工给出一个足够精确的I</p>
</li>
</ol>
<h4 id="lecture-12-from-verification-conditions-to-synthesis-conditions">Lecture 12: From Verification Conditions to Synthesis Conditions.<a class="headerlink" href="#lecture-12-from-verification-conditions-to-synthesis-conditions" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>我们之前通过vc来完成了对于程序的限制，但是vc保证sound却不保证accurate。正如之前所说，如果I取得不好可能导致我们找不出precondition，从而无法完成证明。因此可以探索合成对于循环之中invariant I的准确表述。
    <img alt="12-1" src="12-1.png" /></p>
</li>
<li>
<p>我们可以将I表示为关于所有（与之相关）变量的一个函数，返回一个布尔值。并且将vc里面的要求转化为harness test，然后就可以让sketch来帮我们求出对应的I。不对sketch对于变量之间的组合方式以及bounded varification的范围取舍比较有限。</p>
</li>
<li>
<p>这种自动合成循环不变量的方法还可以用于其他应用，例如可以据此证明从一段JAVA代码与自动生成出的SQL代码的等价性，从而开发出自动从JAVA生成SQL的系统。并大幅度提升执行效率。</p>
</li>
<li>
<p>进一步地申发这种思想，我们除了合成一个invariant之外，也能够合成一个完整的程序。例如“Proof Theoretic Synthesis”（PTS），我们可以对其输入一个程序的“脚手架”，表述了程序的循环结构，以及期望的pre/post-condition，以及一些其他的限制条件。</p>
<p>这个项目的主要贡献是：</p>
<ul>
<li>发现synthesizer倾向于生成循环体，导致程序永不终结，因此partial-correct是不够的，我们需要将程序终止加入合成要求之中</li>
<li>采用了parallel assignment，即尽量将变量的赋值整合在一起，使得当某个前提条件满足的时候，可以对于多个变量同时赋值，以避免其赋值顺序可以交换所带来的对称性问题。</li>
<li>parallel assignment还可以限制程序的分支结构，使其更加可控，以便于生成vc语句即使condition与赋值语句都还没确定。</li>
</ul>
</li>
</ol>
<h4 id="lecture-13-functional-synthesis-with-sketch">Lecture 13: Functional Synthesis with Sketch<a class="headerlink" href="#lecture-13-functional-synthesis-with-sketch" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>前面讲到可以利用harness测试自动找出循环不变量从而完成对于循环的证明，但是有时候这样做会要求生成的代码比原有的代码更加复杂，因此可以改为使用循环/递归展开来处理。
    <img alt="13-1" src="13-1.png" /></p>
<p>具体地说，如果事先不知道循环会进行多少层，那么就将其展开一个特定的层数，并且内嵌到原有的代码之中，如果发现超出了层数，就会直接assert false（但不能assume false，这会导致将否命题加入条件之中，使得程序每次想要生成代码，就直接生成一个超过层数的，这样推任何命题都为真）。</p>
</li>
<li>
<p>之前还提到过CEGIS对于一个counter example只能处理掉少数可能的取值的情况效果不好，更加具体地说，由于举一个反例通常除了input之外还需要举出中间变量的值，这就导致反例容易举出但是适用范围较窄。</p>
<p>形式化的来说，<span class="arithmatex">\(\exists \phi, \forall in,tmp,\;P(\phi,in,tmp)\Rightarrow Q(\phi,in,tmp)\)</span>是程序合成的目标，但是给定一个IN 作为反例，与其寻找到<span class="arithmatex">\(\phi\)</span>使得上式成立，不如根据数理逻辑，找到tmp使得P不成立，这样同样可以达到目标。</p>
</li>
<li>
<p>基于此，可以将上式改写为<span class="arithmatex">\(\exists \phi, \forall in,\exists tmp,\;P(\phi,in,tmp)\wedge Q(\phi,in,tmp)\)</span>，这样虽然不用对任意tmp都满足，但是至少要求存在tmp满足P。这会将找出tmp的任务也交给synthesizer，从而避免上述情况的出现。不过，verification过程还是要用到原来的约束。</p>
</li>
<li>
<p>sketch借鉴了上述的思想，并应用于model一个复杂函数，通过对于一个uninterpreted function施加限制，其中uninterpreted function即对于相同的输入，总是具有相同的输出，这样的函数。例如<img alt="13-2" src="13-2.png" />
    这种模块可以解决CEGIS无法很好工作的情况。</p>
</li>
</ol>
<h4 id="lecture-14-introduction-to-smt">Lecture 14: Introduction to SMT.<a class="headerlink" href="#lecture-14-introduction-to-smt" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>在SAT的基础值之上，我们还需要接触到Satisfiability Modulo Theory Solvers，即SMT solver，它可以处理包含更多谓词种类以及变量关系的可满足性问题。</p>
</li>
<li>
<p>首先定义theory就表示一系列预先确定的公理，它们为所有的谓词与函数赋予信息。SMT的目的就是找到在特定theory之下的某一个公式，是否存在使其满足的特定赋值。为此又需要借助两个概念：Linear integer arithmetic以及Equality with uninterpreted functions。</p>
<ul>
<li>前者处理只包含加运算(乘法，减法等也可以化作加运算处理)以及&gt;,=等简单比较谓词的整数运算系统，目前已经有足够好的算法来进行解决。</li>
<li>后者利用前文提到的uninterpreted function(UI)的性质，即输入一样必然有输出一样，来进行涉及函数运算的相等判定，例如下图之中，通过一系列复杂的推导，推出了矛盾。<img alt="14-1" src="14-1.png" /></li>
</ul>
</li>
<li>
<p><img alt="14-2" src="14-2.png" /></p>
<p>Nelson Oppen算法是解决SMT问题的算法，其核心思想是首先进行purification,即将整个公式拆分为若干个子公式的交，可以通过引入新的变量来使得子公式尽量简单，例如<span class="arithmatex">\(f(a+b,2)\Rightarrow f(c,2)\wedge c=a+b\)</span>。然后对这些子公式应用上述两种方法进行equality propagation，即相等关系的推导与传播，直到最后找出解或者推出矛盾。</p>
<p>这个方法是sound的，因为它如果发现矛盾，那就肯定有矛盾，但不见得是complete的，因为可能有一些矛盾无法被发现。例如</p>
<div class="arithmatex">\[
x\geq 1\\\\
x\leq 2\\\\
f(1)\neq f(x);\\\\
f(2)\neq f(x);
\]</div>
<p>在x是整数的情况之下，这显然是无法满足的，但是为了推导出x等于1或2，我们还必须要求这一套理论具有凸性，即从<span class="arithmatex">\((x=1)\vee(x=2)\)</span>之中它必须能推出其中某一个成立，而不能因为没办法完全确定就停止推导。现实之中我们可以采取回溯搜索的方法来解决这一问题，例如当x的取值不多的时候，就将每种赋值都尝试一次，看看能否推出什么。</p>
</li>
<li>
<p>除此之外，另一种解决SMT问题的思想是利用SATsolver来解决，例如对于以下公式：
    $$
    f(x_1)\neq f(x_2)\\
    x_1 =a\vee x_1=b\\
    x_2=a\vee x_2=b\\
    a=b
    $$
    如果用一个布尔值来替代相等关系，就可以转换为
    $$
    \neg t_1\\
    t_2\vee t_3\\
    t_4\vee t_5\\
    t_6
    $$
    如果转换之后的公式<span class="arithmatex">\(B_F\)</span>都无法满足，那么之前的公式也肯定无法满足。</p>
<p>为了给予转换之后的公式更多的信息，可以考虑尽可能将原有的等价推导信息尽可能用布尔表达式表示出来，例如<span class="arithmatex">\(t_6\Rightarrow(t_2\Rightarrow t_3)\)</span>,然后将所有这些布尔表达式也加为限制条件，就可以得到与原问题等价的SAT问题。但是这样做通常吃力不讨好，因为要将原问题的信息全部用布尔表达式提取出来是很费时费力的事情，因此另一种思想是增量式的对其进行寻找。</p>
</li>
<li>
<p>DPLL(T)算法的思想正是如此，他的想法有点类似于CEGIS。</p>
<p>首先将SMT按照上述方式转化为一个初始的SAT问题，然后交给SAT来求解，如果无解当然就肯定无法满足。反之SAT给出了所有布尔表达式的一种赋值方式<span class="arithmatex">\(t_1=true,t_2=false...\)</span>，可以让SMT solver来看能否让原问题满足这一赋值，当发现可以的话求解就完成。反之说明这种布尔表达式的赋值方式是错误的，将其取反<span class="arithmatex">\(\overline{t_1}\vee t_2\vee...\)</span>加入SAT的限制之中。重复上述过程即可。</p>
<p>DPLL(T)有若干优化的思想，例如让SMT solver更高效的由布尔表达式进行求解或推出矛盾，以及尽可能利用较少的布尔表达式赋值就推出矛盾（能否只知道<span class="arithmatex">\(t_1,t_2\)</span>的值就推出矛盾？）然后将尽量简短的布尔表达式加入SAT限制之中（<span class="arithmatex">\(\overline{t_1}\vee t_2\)</span>够吗？），使得每个反例能够更大程度的缩小搜索空间。</p>
</li>
</ol>
<h4 id="lecture-15-expressive-types">Lecture 15: Expressive Types.<a class="headerlink" href="#lecture-15-expressive-types" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>之前我们见识到了类型系统可以帮助enumerative synthesis的过程进行剪枝，它的作用有点类似于物理学中的量纲，除了帮助我们进行简化之外，本身并不能进行太多的计算与推导。但是如果对于类型进行细化，得到refinement type，或许可以提供更多的功能。</p>
</li>
<li>
<p>定义<span class="arithmatex">\(\{v:B|P(v)\}\)</span>表示一个细化类型，为类型B之中所有满足谓词P的元素（感觉相比于一个类型更靠近于“同种元素的集合”这一概念）。<img alt="image-20221011162350500" src="image-20221011162350500.png" /></p>
<p>这里定义了一个简单的类型系统，并且有一些初始规则，来进行类型推导，但是仅凭这些初始规则依然推导不出太多有用的信息，为此还必须要引入子类型subtype的概念。</p>
</li>
<li>
<p>定义<span class="arithmatex">\(T_1&lt;:T_2\)</span>表示子类型关系，即任何需求<span class="arithmatex">\(T_2\)</span>的场合都可以用<span class="arithmatex">\(T_1\)</span>类型的变量来替代，这样我们就可以通过子类型关系的推导来完成。</p>
<p><img alt="image-20221011164725879" src="image-20221011164725879.png" /></p>
<p>不过感觉这也很类似于之前的constraint-based verification过程。</p>
</li>
<li>
<p>这种细化类型允许我们在类型检查的时候能够检查出能加复杂的性质，例如以下例子：<img alt="image-20221011185046141" src="image-20221011185046141.png" /></p>
<p><span class="arithmatex">\(Nil\rightarrow Nil\)</span>这个步骤出现了错误，但是如果我们只知道返回值是list的话就无法检查出来，但是将列表长度添加进类型属性之中，就可以在静态分析阶段发现并报出这个错误。</p>
</li>
</ol>
<h4 id="lecture-16-synthesis-with-refinement-types">Lecture 16: Synthesis with Refinement Types.<a class="headerlink" href="#lecture-16-synthesis-with-refinement-types" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>上文之中提到refinement type可以帮助我们做类型检查，因此合理推断，也可以将这一技术应用于程序合成之中，帮助我们排除掉不需要的程序，完成剪枝。</p>
</li>
<li>
<p>一种常见的类型检查技术是*Bidirectional typechecking*。简单的理解这种方法，就是它既会top-down propagation,又会bottom-up propagation。例如我们有：</p>
<div class="language-haskell highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="nf">f</span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="p">{</span><span class="n">v</span><span class="kt">:Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="nf">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="ow">=</span><span class="n">min</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
</span></code></pre></div>
<p>那么首先会将第一行的type signature应用到其参数之上，检查a,b的类型，然后根据a,b的取值推断返回值类型是否是我们所需要的。</p>
</li>
<li>
<p>另外一种类型检查技术是round-trip type checking。它的核心思想是类型检查可以被不断细化，以下面这个例子说明：</p>
<p><img alt="image-20221018105405951" src="image-20221018105405951.png" /></p>
<p>按照之前的Bidirectional typechecking方法来看，我们为了知道返回值的类型，需要先知晓每一个参数的类型以及取值。但是round-trip typechecking可以直接跳过这一步，先试一下粗略的要求能否满足返回值，并且利用返回值的信息进一步推断对于参数的限制，如果限制不能满足，那么就可以直接报错，否则再进一步细化要求。</p>
<p>在这个例子之中，即使不知道x,xs的值，也可以直接检查返回值<code>Cons h (insert x ...)</code>是否是SList（这个类型是一个sorted list,其中的元素升序排布）。然后根据Cons的语义以及其返回值的信息，推知<code>insert x ...</code>也必须是一个<code>SList {v:e|v&gt;=h}</code>即所有元素不小于h的sorted list。</p>
<p>由于在程序合成之中可能出现目前未知的hole，即我们暂时不知道填什么，比如这里的... 所以我们希望对此情况，type checker也能尽量作出判决。对此的检查Bidirectional typechecking只能一一枚举...之中可能的内容。但是round-trip typechecking可以根据insert返回值的类型<code>SList {v:e|v&gt;=h}</code>，以及insert本身的语义信息，推知x的类型是<code>{v:e|v&gt;=h}</code>，然而x本身的类型并不满足，因此这里可以直接报错。</p>
<p>毫无疑问，这样的类型检查方式更为高效。</p>
</li>
<li>
<p>一个已经基于refinement types实现的程序合成系统是Synquid，他设计的核心思想是首先利用top-down enumerative search，在其中通过Round-trip type checking思想来剪枝。</p>
<p>除此之外，它还引入了类似于STUN（先合成一个程序，然后对于无法满足的input再合成一个程序，最后将二者结合起来）的思想。但由于没有concrete input，只能先找到一个weakest predicate P,使得我们可以合成一个程序<span class="arithmatex">\(C_t\)</span>在这个假设之下工作。然后考虑P为假的情况，将其加入条件之中，重复上述步骤，直到找出<span class="arithmatex">\(C_f\)</span>在此时工作，最后通过<span class="arithmatex">\(if(P)C_t\; else\; C_f\)</span>这样的方式将其结合起来。</p>
</li>
</ol>
<h4 id="lecture-17-deductive-synthesis">Lecture 17: Deductive Synthesis<a class="headerlink" href="#lecture-17-deductive-synthesis" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>deductive synthesis(演绎合成)是另外一种程序合成的泛式，如果说之前介绍的方法思想都是不断缩小搜索空间，直到找到合适的解，那么演绎合成的思想就是通过施加一系列变换规则，从原始程序得到一个更加高效的实现。</p>
</li>
<li>
<p>下面是一个很简单的程序合成系统：A Transformation System for Developing Recursive Programs。</p>
<p>对于一个简单的斐波那契函数：
$$
\begin{align}
f(0)&amp;=1\\
f(1)&amp;=1\\
f(x)&amp;=f(x)+f(y)
\end{align}
$$
我们知道如果不考虑用数组来存储之前得到的结果的话，其时间复杂度是<span class="arithmatex">\(O(2^n)\)</span>但是我们可以通过一系列规则找出一个更好的程序，复杂度为<span class="arithmatex">\(O(n)\)</span>。过程如下：</p>
<ol>
<li>
<p>euraka step:引入一个新的函数<span class="arithmatex">\(g(x)=&lt;f(x+1),f(x)&gt;\)</span></p>
</li>
<li>
<p>instantiation:引入新的实例，即将自变量x变成一些其他表达式，然后代入原式得<span class="arithmatex">\(g(x+1)=&lt;f(x+2),f(x+1)&gt;\)</span></p>
</li>
<li>
<p>unfold:利用之前定义的规则展开表达式<span class="arithmatex">\(g(x+1)=&lt;f(x+1)+f(x),f(x+1)&gt;\)</span></p>
</li>
<li>
<p>abstraction:对于局部表达式或变量重命名：<span class="arithmatex">\(g(x+1)=&lt;u+v,u&gt;\;where\;&lt;u,v&gt;=&lt;f(x+1,f(x)&gt;\)</span></p>
</li>
<li>
<p>fold:逆用之前的转换规则引入新的函数调用：<span class="arithmatex">\(g(x+1)=&lt;u+v,u&gt;\;where\;&lt;u,v&gt;=g(x)\)</span></p>
</li>
</ol>
<p>如此我们就找到了求g(x)的线性算法，随后再用g(x)来求f(x+1)即可</p>
</li>
<li>
<p>在1979年有学者提出了更为普适化的方法，着力于从high level的逻辑表达式直接生成出高效的实现。简单地来说，对于某时刻存在如下形式的程序：<span class="arithmatex">\(f(in)\Leftarrow expr\)</span>,其中expr表示在某个条件之下要进行何种操作，然后通过一系列保证正确性的转换方式对于expr不断进行变换，最后得出一个保证正确并且较为高效的程序。例如以下的规则</p>
<ul>
<li>
<p>empty lists:对于空集l,任何对它的所有元素有某种要求的谓词P都为真<span class="arithmatex">\(P(all(l))\Rightarrow true\)</span></p>
</li>
<li>
<p>conditional formation:对于某个谓词P，可以对其divide and conquer: 
   $$
   S\;where\;Q\Rightarrow if(P)\;S\;where(P\wedge Q)\
   else\;S\;where(\neg P\wedge Q)
   $$</p>
</li>
<li>
<p>non empty lists:对于某个list的所有元素有某种要求P的话，可以将其拆分为首元素与其他元素分别作要求：
   $$
   P(all(l))\Rightarrow P(head(l))\wedge P(all(tail(l)))\
   if\;l\;not\;empty
   $$</p>
</li>
<li>
<p>recursive call formation：类似于之前提到的fold,观察此时的程序之中是否有某些组件符合函数调用的形式，并尽量用函数调用替换原先的组件。</p>
</li>
</ul>
<p>这篇文章阐释了一系列演绎合成的优势，例如*correct by construction*，即这个程序合成系统本身就保证了程序的正确性，因为它的每一步变换都维护了原有的语义信息。而非如同CEGIS一般，依赖于verification来保证最后合成出的程序是正确的。</p>
</li>
<li>
<p>在历史上，演绎合成的应用遇到了诸多的困难，例如我们对于某个程序状态，可能很难得出当前应该应用哪一条转换规则，比如在上述的conditional formation规则之中，可能就无法确定该对于哪一个谓词P进行分支。因此演绎合成对于大型程序可能要经历一段级长的时间，结合上搜索剪枝等策略才能得到结果。而且对于某一项任务，通常会添加很多heuristic的策略或规则来帮助整个系统运作，这不但对人工的需求大，而且也不易迁移任务。</p>
<p>当然也有不少较为成功的应用，例如spiral system，演绎合成被用于合成信号处理操作，例如快速傅里叶变换和其他线性变换等的结合。对于这些narrow domain，人们通常可以方便地定制domain-specific transformation rules，这也就让演绎合成得以大展拳脚，快速合成出超过人工专家的高效方案。</p>
</li>
</ol>
<p>（未完待续~）</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.cd18aaf1.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>